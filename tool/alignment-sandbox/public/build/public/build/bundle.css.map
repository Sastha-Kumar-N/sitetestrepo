{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Heatmap.svelte"
  ],
  "sourcesContent": [
    "<script>\nimport { onMount } from \"svelte\";\nimport Aioli from \"@biowasm/aioli\";\nimport Parameter from \"./Parameter.svelte\";\nimport Heatmap from \"./Heatmap.svelte\";\n\n\n// -----------------------------------------------------------------------------\n// Globals\n// -----------------------------------------------------------------------------\n\n// User input\nlet Seq1 = \"GGTTGACTA\";\nlet Seq2 = \"TGTTCGG\";\nlet Params = [];\nlet Options = {\n\tmatch: 3,\n\tmismatch: -3,\n\tgapopen: 0,\n\tgapextend: -2,\n};\n// Aioli/WebAssembly setup\nlet ready = false;\nlet CLI;\n// Output\nlet Result = {\n\tsw: \"Loading...\",\n\tnw: \"Loading...\"\n};\nlet Matrix = {\n\tsw: [],\n\tnw: []\n};\nlet Pointers = {\n\tsw: [],\n\tnw: []\n}\n\n\n// -----------------------------------------------------------------------------\n// Reactive Statements\n// -----------------------------------------------------------------------------\n\n// Update CLI parameters when user updates settings\n$: Params = Object.keys(Options).map(arg => {\n\tlet value = Options[arg];\n\tif(value === null)\n\t\treturn \"\";\n\tif(typeof value === \"boolean\")\n\t\treturn value === true ? `--${arg}` : \"\";\n\treturn `--${arg} ${value}`;\n}).filter(d => d != \"\").join(\" \").trim();\n\n// Debugging\n$: console.log(`Parameters: ${Params}`);\n\n\n// -----------------------------------------------------------------------------\n// On page load\n// -----------------------------------------------------------------------------\n\nonMount(async () => {\n\t// Initialize wasm tools\n\tCLI = await new Aioli([\n\t\t\"seq-align/smith_waterman/2017.10.18\",\n\t\t\"seq-align/needleman_wunsch/2017.10.18\"\n\t], { printInterleaved: false })\n\tlaunch();\n\n\t// Enable jQuery tooltips\n\tjQuery(\"[data-toggle='popover']\").popover();\n});\n\n\n// -----------------------------------------------------------------------------\n// Launch alignments\n// -----------------------------------------------------------------------------\n\nasync function launch()\n{\n\tready = false;\n\n\t// Run Smith-Waterman algorithm\n\tawait CLI\n\t\t.exec(`smith_waterman --printmatrices ${Params} ${Seq1} ${Seq2}`)\n\t\t.then(d => parseOutput(d, \"sw\"));\n\n\t// Run Needleman-Wunsch algorithm\n\tawait CLI\n\t\t.exec(`needleman_wunsch --printmatrices --printscores ${Params} ${Seq1} ${Seq2}`)\n\t\t.then(d => parseOutput(d, \"nw\"));\n\n\t// Re-enable UI parameters once everything is done loading\n\tready = true;\n}\n\n\n// -----------------------------------------------------------------------------\n// Utility functions\n// -----------------------------------------------------------------------------\n\n// Parse results and dynamic programming matrices from output\nfunction parseOutput(out, algorithm)\n{\n\t// Stop if errors\n\tif(out.stderr != \"\") {\n\t\tResult[algorithm] = d.stderr;\n\t\treturn;\t\t\n\t}\n\n\t// Extract DP matrices from stdout\n\tlet result = \"\";    // seq-align output displayed to user (excluding matrices)\n\tlet which = null;   // which matrix we're extracting\n\tlet matrices = {};  // all three matrices\n\tlet matrix = [];    // the matrix we get by combining info from all three matrices\n\tlet pointers = [];  // matrix to help us backtrack\n\tlet stdout = out.stdout.split(\"\\n\");\n\tfor(let line of stdout)\n\t{\n\t\t// Matrices in the output are prepended with their description\n\t\tif(line == \"match_scores:\") {\n\t\t\twhich = \"match\";\n\t\t} else if(line == \"gap_a_scores:\") {\n\t\t\twhich = \"gap_a\";\n\t\t} else if(line == \"gap_b_scores:\") {\n\t\t\twhich = \"gap_b\";\n\t\t} else if(line.startsWith(\"match: \")) {\n\t\t\twhich = null;\n\t\t// If we're at a line from a matrix, split the output into an array\n\t\t} else if(which != null) {\n\t\t\tif(!(which in matrices))\n\t\t\t\tmatrices[which] = [];\n\t\t\tlet values = line.split(\":\").pop().trim().split(/\\s+/).map(d => +d);\n\t\t\tmatrices[which].push(values);\n\t\t// Keep track of the non-DP output\n\t\t} else if(line.trim() != \"\" && !line.startsWith(\"==\") && !line.startsWith(\"seq_a:\") && !line.startsWith(\"seq_b:\")) {\n\t\t\tresult += `${line}\\n`;\n\t\t}\n\t}\n\tResult[algorithm] = result;\n\n\t// Generate a single DP matrix from the three matrices\n\tfor(let rowNb in matrices.match) {\n\t\tmatrix[rowNb] = [];\n\t\tpointers[rowNb] = [];\n\t\tfor(let colNb in matrices.match[rowNb])\n\t\t{\n\t\t\t// Track max value\n\t\t\tmatrix[rowNb][colNb] = Math.max(\n\t\t\t\tmatrices.match[rowNb][colNb],\n\t\t\t\tmatrices.gap_a[rowNb][colNb],\n\t\t\t\tmatrices.gap_b[rowNb][colNb],\n\t\t\t);\n\t\t\t// But also whether it was a match, insertion or deletion to help us backtrack later\n\t\t\tpointers[rowNb][colNb] = [ matrices.match[rowNb][colNb],\n\t\t\t\tmatrices.gap_a[rowNb][colNb],\n\t\t\t\tmatrices.gap_b[rowNb][colNb]\n\t\t\t].indexOf(matrix[rowNb][colNb]);\n\t\t}\n\t}\n\n\tMatrix[algorithm] = matrix;\n\tPointers[algorithm] = pointers;\n}\n\n\n// -----------------------------------------------------------------------------\n// HTML\n// -----------------------------------------------------------------------------\n</script>\n\n<style>\npre {\n\theight: 10vh;\n\tborder: 1px solid #ccc;\n}\n\n@media screen and (max-width: 800px) {\n\tpre {\n\t\theight: 100px;\n\t}\n}\n</style>\n\n<nav class=\"navbar navbar-expand-md navbar-dark fixed-top bg-dark\">\n  <a class=\"navbar-brand\" href=\"https://bharatgenomedatabase.org\"><img src=\"logo.png\" alt=\"Logo\" style=\"height: 30px; width: auto;\"></a>\n\t<a class=\"navbar-brand\" href=\"https://bharatgenomedatabase.org\">BGDB Alignment Tool</a>\n\t<div class=\"collapse navbar-collapse\">\n\t\t<ul class=\"navbar-nav mr-auto\"></ul>\n\t\t<ul class=\"navbar-nav\">\n\t\t\t<li class=\"nav-item active\">\n\t\t\t\t<a class=\"nav-link\" href=\"https://bharatgenomedatabase.org\">Home</a>\n\t\t\t</li>\n\t\t\t<li class=\"nav-item active\">\n\t\t\t\t<a class=\"nav-link\" href=\"https://github.com/robertaboukhalil/alignment-sandbox\">Code</a>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n</nav>\n\n<main>\n\t<div class=\"jumbotron mb-3 pb-2\">\n\t\t<div class=\"container\">\n\t\t\t<!-- Input Parameters -->\n\t\t\t<div class=\"row mt-4 mt-sm-0\">\n\t\t\t\t<div class=\"col-12 col-sm-6 mt-2 mt-sm-0 border-right\">\n\t\t\t\t\t<p><strong>Sequences to align:</strong></p>\n\t\t\t\t\t<Parameter col=\"0\" disabled={!ready} on:launch={launch} bind:value={Seq1} />\n\t\t\t\t\t<Parameter col=\"0\" disabled={!ready} on:launch={launch} bind:value={Seq2} />\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-12 col-sm-6 col-md-2 mt-2 mt-sm-0 border-right\">\n\t\t\t\t\t<p><strong>Match Scores:</strong></p>\n\t\t\t\t\t<Parameter label=\"Match\" disabled={!ready} on:launch={launch}  help=\"Score given to matching bases\" bind:value={Options.match} />\n\t\t\t\t\t<Parameter label=\"Mismatch\" disabled={!ready} on:launch={launch}  help=\"Penalty for mismatches\" bind:value={Options.mismatch} />\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-12 col-sm-6 col-md-2 mt-2 mt-sm-0 border-right\">\n\t\t\t\t\t<p><strong>Gap Penalties:</strong></p>\n\t\t\t\t\t<Parameter label=\"Open\" disabled={!ready} on:launch={launch}  help=\"Penalty for starting a gap. Set to 0 to disable affine gap penalties.\" bind:value={Options.gapopen} />\n\t\t\t\t\t<Parameter label=\"Extend\" disabled={!ready} on:launch={launch}  help=\"Penalty for each base that extends an open gap.\" bind:value={Options.gapextend} />\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-12 col-sm-6 col-md-2 mt-2 mt-sm-0 mb-2 mb-sm-0\">\n\t\t\t\t\t<p class=\"d-none d-sm-block\">&nbsp;</p>\n\t\t\t\t\t<button on:click={launch} style=\"width:100%\" disabled={!ready} on:launch={launch}  class=\"btn btn-primary btn-lg pt-4 pb-4\">Align</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<div class=\"container\">\n\t\t<div class=\"row\">\n\t\t\t<!-- Smith-Waterman alignment output -->\n\t\t\t<div class=\"col-md-6 mb-2\">\n\t\t\t\t<h4 class=\"mb-3\">Smith-Waterman</h4>\n\t\t\t\t<pre>{Result.sw}</pre>\n\t\t\t\t<Heatmap algorithm=\"sw\" seq1={Seq1} seq2={Seq2} matrix={Matrix.sw} pointers={Pointers.sw} />\n\t\t\t</div>\n\n\t\t\t<!-- Needleman-Wunsch alignment output -->\n\t\t\t<div class=\"col-md-6 mb-2\">\n\t\t\t\t<h4 class=\"mb-3\">Needleman-Wunsch</h4>\n\t\t\t\t<pre>{Result.nw}</pre>\n\t\t\t\t<Heatmap algorithm=\"nw\" seq1={Seq1} seq2={Seq2} matrix={Matrix.nw} pointers={Pointers.nw} />\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</main>\n",
    "<script>\nimport { onMount } from \"svelte\";\n\nexport let algorithm = null;  // Accepted: \"sw\" (Smith-Waterman) or \"nw\" (Needleman-Wunsch)\nexport let seq1 = \"\";\nexport let seq2 = \"\";\nexport let matrix = [];\nexport let pointers = [];\n\n\n// =============================================================================\n// Reactive statements\n// =============================================================================\n\n// Plot heatmap when matrix is defined\n$: if(matrix.length > 0) {\n    plot();\n}\n\n\n// =============================================================================\n// Utility functions\n// =============================================================================\n\n// Convert sequence to list of subscripted bases\n// e.g. \"ACATC\" --> \"A1, C1, A2, T1, C2\"\nfunction seqToArray(seq)\n{\n\tlet n = 1;\n\tlet w = seq.split(\"\").map(d => `${d}<sub>${n++}</sub>`);\n\treturn [\"\"].concat(w);\n}\n\n\n// =============================================================================\n// Calculate backtrack from the dynamic programming matrix\n// =============================================================================\n\nfunction getBacktrack()\n{\n    // -------------------------------------------------------------------------\n    // Calculate start coordinates of backtrack\n    // -------------------------------------------------------------------------\n    let rowNb = -1;\n    let colNb = -1;\n\n    // Needleman-Wunsch is a global alignment algorithm so start at bottom right corner\n    if(algorithm == \"nw\") {\n        rowNb = matrix.length - 1;\n        colNb = matrix[0].length - 1;\n    }\n\n    // Smith-Waterman is a local alignment algorithm so start at position with max score\n    else if(algorithm == \"sw\")\n    {\n        // Find largest number in the matrix\n        // Note: use \"...\" since Math.max() doesn't support array inputs\n        let max = Math.max(...matrix.map(row => Math.max(...row)));\n        // Find coordinates of that max\n        while(colNb == -1)\n            colNb = matrix[++rowNb].indexOf(max);\n    }\n\n    // -------------------------------------------------------------------------\n    // Do the backtrack\n    // -------------------------------------------------------------------------\n    let backtrack = [];\n    // For global alignment, we backtrack until we get to (0, 0)\n    while(rowNb >= 0 && colNb >= 0)\n    {\n        // Save coordinates as a linear array to simplify comparisons later on\n        backtrack.push(matrix[0].length * rowNb + colNb);\n\n        // For local alignment, we stop backtracking when we reach a value of 0\n        if(algorithm == \"sw\" && matrix[rowNb][colNb] == 0)\n            break;\n\n        // Where to go next?\n        //       || j - 1 |  j\n        // ======||=======|=====\n        // i - 1 ||   0   |  1\n        // ------||-------|-----\n        //   i   ||   2   |  *\n        let whichDirection = pointers[rowNb][colNb];\n        if(whichDirection == 0) {\n            rowNb -= 1; colNb -=1;\n        } else if(whichDirection == 1) {\n            rowNb -= 1;\n        } else if(whichDirection == 2) {\n            colNb -=1;\n        }\n    }\n\n    return backtrack;\n}\n\n\n// =============================================================================\n// Plot heatmap\n// =============================================================================\n\nfunction plot()\n{\n    // Generate Plotly annotations\n    let n = 0;\n    let annotations = [];\n    let backtrack = getBacktrack();\n    for(let rowNb in matrix)\n    {\n        for(let colNb in matrix[rowNb])\n        {\n            let bordercolor = false;\n            if(backtrack.includes(n))\n                bordercolor = \"white\";\n            annotations.push({\n                x: colNb,\n                y: rowNb,\n                text: matrix[rowNb][colNb],\n                showarrow: false,\n                bordercolor: bordercolor,\n                borderwidth: 3,\n                borderpad: 5\n            })\n            n += 1;\n        }\n    }\n\n    // Create or update plot\n    Plotly.react(`heatmap-${algorithm}`, [{\n        x: seqToArray(seq1),\n        y: seqToArray(seq2),\n        z: matrix,\n        type: \"heatmap\",\n        showscale: false,\n        hoverinfo: \"skip\",\n        hovertemplate: \"%{x}, %{y}<extra> %{z}</extra>\",\n    }], {\n        margin: { t: 30, l: 30, r: 20, b: 5 },\n        annotations: annotations,\n        xaxis: { side: \"top\" },\n        yaxis: { autorange: \"reversed\" },\n    }, {\n        displayModeBar: false\n    });\n}\n</script>\n\n<style>\n.heatmap {\n\tmax-height: 50vh;\n}\n\n@media screen and (max-height: 500px) {\n    .heatmap {\n        max-height: 400px;\n    }\n}\n</style>\n\n<div class=\"heatmap\" id=\"heatmap-{algorithm}\"></div>\n"
  ],
  "names": [],
  "mappings": "AA4KA,GAAG,eAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,AACvB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACrC,GAAG,eAAC,CAAC,AACJ,MAAM,CAAE,KAAK,AACd,CAAC,AACF,CAAC;ACjCD,QAAQ,cAAC,CAAC,AACT,UAAU,CAAE,IAAI,AACjB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,KAAK,CAAC,AAAC,CAAC,AACnC,QAAQ,cAAC,CAAC,AACN,UAAU,CAAE,KAAK,AACrB,CAAC,AACL,CAAC"
}